> Task Adserver

**Description:**

You are tasked with building a simple task management application that
allows users to

create, update, and view tasks. The application should have the
following functionality:

> 1\. Task Creation: Users should be able to create a new task by
> providing a title, de-
>
> scription, and due date. Each task should have a unique identiﬁer.
>
> 2\. Task Update: Users should be able to update an existing task by
> changing its title,
>
> description, or due date.
>
> 3\. Task Listing: Users should be able to view a list of all tasks,
> sorted by their due
>
> dates. Each task in the list should display its title, description,
> due date, and sta-
>
> tus (e.g., pending, completed).
>
> 4\. Task Completion: Users should be able to mark a task as completed,
> indicating
>
> that it has been ﬁnished.

**Requirements:**

> 1\. Implement the application using a programming language or
> framework of your
>
> choice. Provide clear instructions on how to run the application.
>
> 2\. Use appropriate data structures and algorithms to store and
> manipulate the tasks.
>
> 3\. Design a user-friendly command-line interface (CLI) or graphical
> user interface
>
> (GUI) for interacting with the application. Consider the ease of use
> and intuitive-
>
> ness of the interface.
>
> 4\. Ensure proper input validation and error handling to handle
> invalid user inputs and
>
> edge cases.
>
> 5\. Write clear and well-structured code, following best practices and
> coding conven-
>
> tions.
>
> 6\. Include unit tests to validate the correctness of the implemented
> functionalities.
>
> Task Adserver
>
> 7\. Document the implementation, including any assumptions made,
> limitations, and
>
> instructions on how to use the application.

**Evaluation** **Criteria:**

> · Correctness and completeness of the implemented functionalities.
>
> · Quality and readability of the code.
>
> · Eﬀective use of data structures and algorithms.
>
> · User-friendliness and intuitiveness of the interface.
>
> · Proper input validation and error handling.
>
> · Test coverage and eﬀectiveness of unit tests.
>
> · Clarity and completeness of the documentation.
